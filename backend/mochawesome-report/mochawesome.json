{
  "stats": {
    "suites": 9,
    "tests": 41,
    "passes": 41,
    "pending": 0,
    "failures": 0,
    "start": "2025-06-17T15:47:05.192Z",
    "end": "2025-06-17T15:47:05.874Z",
    "duration": 682,
    "testsRegistered": 41,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false
  },
  "results": [
    {
      "uuid": "d4f56405-3ca1-46d3-9f9c-12657ddad6c2",
      "title": "",
      "fullFile": "",
      "file": "",
      "beforeHooks": [
        {
          "title": "\"before all\" hook in \"{root}\"",
          "fullTitle": "\"before all\" hook in \"{root}\"",
          "timedOut": false,
          "duration": 73,
          "state": null,
          "speed": null,
          "pass": false,
          "fail": false,
          "pending": false,
          "context": null,
          "code": "await createTestDB(config.db.database, config.db.user);\nawait createTables(config.db.user, config.db.database);",
          "err": {},
          "uuid": "6a84d765-21e2-4b11-9567-3bf1e74a8180",
          "parentUUID": "d4f56405-3ca1-46d3-9f9c-12657ddad6c2",
          "isHook": true,
          "skipped": false
        }
      ],
      "afterHooks": [],
      "tests": [],
      "suites": [
        {
          "uuid": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
          "title": "Tests de base de données",
          "fullFile": "/home/johan/Repository/ikanban/backend/test/1-database.test.ts",
          "file": "/test/1-database.test.ts",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "doit insérer un utilisateur",
              "fullTitle": "Tests de base de données doit insérer un utilisateur",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('INSERT INTO users (id, name, email, password_hash) VALUES ($1, $2, $3, $4) RETURNING *', [\n    '75a745c9-975f-4826-a263-13d1dbb2eec5',\n    'tester1',\n    'tester1@example.com',\n    'hashed_password',\n]);\nassert.equal(result.rows[0].name, 'tester1');\nassert.equal(result.rows[0].email, 'tester1@example.com');\nassert.equal(result.rows[0].password_hash, 'hashed_password');",
              "err": {},
              "uuid": "ba4dea07-829c-4235-98ae-fe4a45cc9ec9",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit insérer un second utilisateur",
              "fullTitle": "Tests de base de données doit insérer un second utilisateur",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('INSERT INTO users (id, name, email, password_hash) VALUES ($1, $2, $3, $4) RETURNING *', [\n    '2691cd19-1633-46cc-a7b6-15f98e457e71',\n    'tester2',\n    'tester2@example.com',\n    'hashed_password',\n]);\nassert.equal(result.rows[0].name, 'tester2');\nassert.equal(result.rows[0].email, 'tester2@example.com');\nassert.equal(result.rows[0].password_hash, 'hashed_password');",
              "err": {},
              "uuid": "80530f5e-be5a-405d-8ac3-767ed2408fae",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas insérer un utilisateur avec le même mail",
              "fullTitle": "Tests de base de données ne doit pas insérer un utilisateur avec le même mail",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "try {\n    await pool.query('INSERT INTO users (id, name, email, password_hash) VALUES ($1, $2, $3, $4) RETURNING *', [\n        '780afe11-6d37-4cd3-9d96-b444af4ff06e',\n        'tester3',\n        'tester1@example.com',\n        'hashed_password',\n    ]);\n    // Si aucune erreur n'est levée, on échoue explicitement le test\n    // L'unicité du champ mail n'est pas respecté\n    assert.fail(\"L'erreur attendue n'a pas été détectée\");\n}\ncatch (error) {\n    if (error instanceof Error) {\n        // Passe le test si le message d'erreur de violation d'unicité retourné par PostgreSQL\n        // correspond exactement à ce que l'on attend dans ce cas\n        assert.ok(error.message.includes(\"la valeur d'une clé dupliquée rompt la contrainte unique\"), `Erreur inattendue : ${error.message}`);\n    }\n    else {\n        // Force le test à échouer dans ce cas, peu de chance...\n        assert.fail(\"Erreur inattendue, l'objet n'est pas de type Error.\");\n    }\n}",
              "err": {},
              "uuid": "3a1460c0-5911-4407-8bb8-6fb38dd40605",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit trouver un utilisateur par email",
              "fullTitle": "Tests de base de données doit trouver un utilisateur par email",
              "timedOut": false,
              "duration": 5,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('SELECT * FROM users WHERE email = $1', ['tester1@example.com']);\nassert.equal(result.rowCount, 1);\nassert.equal(result.rows[0].name, 'tester1');\nassert.equal(result.rows[0].email, 'tester1@example.com');",
              "err": {},
              "uuid": "4b2f1e69-9ce3-4c2c-ad46-1ce23c99296f",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas trouver un utilisateur par email inexistant",
              "fullTitle": "Tests de base de données ne doit pas trouver un utilisateur par email inexistant",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('SELECT * FROM users WHERE email = $1', ['inexistant@example.com']);\nassert.equal(result.rowCount, 0);",
              "err": {},
              "uuid": "b1ef3c1b-4052-4156-8ae4-3b0b9155738b",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit mettre à jour le mail d'un utilisateur existant",
              "fullTitle": "Tests de base de données doit mettre à jour le mail d'un utilisateur existant",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('UPDATE users SET email = $1 WHERE name = $2 RETURNING *', ['updated-email@example.com', 'tester1']);\nassert.equal(result.rowCount, 1);\nassert.equal(result.rows[0].email, 'updated-email@example.com');",
              "err": {},
              "uuid": "772b6b60-a7ca-4aa7-b7a9-88e014a4c835",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas mettre à jour l'email avec un email déjà enregistré pour un autre utilisateur.",
              "fullTitle": "Tests de base de données ne doit pas mettre à jour l'email avec un email déjà enregistré pour un autre utilisateur.",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "try {\n    await pool.query('UPDATE users SET email = $1 WHERE name = $2 RETURNING *', ['updated-email@example.com', 'tester2']);\n    assert.fail(\"L'erreur attendue n'a pas été détectée\");\n}\ncatch (error) {\n    if (error instanceof Error) {\n        assert.ok(error.message.includes(\"la valeur d'une clé dupliquée rompt la contrainte unique\"), `Erreur inattendue : ${error.message}`);\n    }\n    else {\n        assert.fail(\"Erreur inattendue, l'objet n'est pas de type Error.\");\n    }\n}",
              "err": {},
              "uuid": "481f8109-ba19-446d-8338-871f5f60d402",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "empêcher l'injection de code SQL",
              "fullTitle": "Tests de base de données empêcher l'injection de code SQL",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const maliciousEmail = \"' OR 1=1 --\";\nconst result = await pool.query('SELECT * FROM users WHERE email = $1', [maliciousEmail]);\nassert.equal(result.rowCount, 0);",
              "err": {},
              "uuid": "cc33f09a-2428-489a-bf41-2d08cf208857",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas autoriser la valeur NULL dans le champ du nom",
              "fullTitle": "Tests de base de données ne doit pas autoriser la valeur NULL dans le champ du nom",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "try {\n    await pool.query('INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3)', [null, 'null@example.com', 'hashed_password']);\n    assert.fail('Expected error but got none');\n}\ncatch (error) {\n    if (error instanceof Error) {\n        assert.ok(error.message.includes('une valeur NULL viole la contrainte NOT NULL'), `Erreur inattendue : ${error.message}`);\n    }\n    else {\n        assert.fail(\"Erreur inattendue, l'objet n'est pas de type Error.\");\n    }\n}",
              "err": {},
              "uuid": "3c143ca4-2d4b-41bd-8d85-fb47182f7ed7",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas autoriser la valeur NULL dans le champ du mail",
              "fullTitle": "Tests de base de données ne doit pas autoriser la valeur NULL dans le champ du mail",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "try {\n    await pool.query('INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3)', ['null', null, 'hashed_password']);\n    assert.fail('Expected error but got none');\n}\ncatch (error) {\n    if (error instanceof Error) {\n        assert.ok(error.message.includes('une valeur NULL viole la contrainte NOT NULL'), `Erreur inattendue : ${error.message}`);\n    }\n    else {\n        assert.fail(\"Erreur inattendue, l'objet n'est pas de type Error.\");\n    }\n}",
              "err": {},
              "uuid": "f0d0b866-59df-421a-be60-95ae39cf97cd",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas autoriser la valeur NULL dans le champ du mot de passe",
              "fullTitle": "Tests de base de données ne doit pas autoriser la valeur NULL dans le champ du mot de passe",
              "timedOut": false,
              "duration": 4,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "try {\n    await pool.query('INSERT INTO users (name, email, password_hash) VALUES ($1, $2, $3)', ['null', 'null@example.com', null]);\n    assert.fail('Expected error but got none');\n}\ncatch (error) {\n    if (error instanceof Error) {\n        assert.ok(error.message.includes('une valeur NULL viole la contrainte NOT NULL'), `Erreur inattendue : ${error.message}`);\n    }\n    else {\n        assert.fail(\"Erreur inattendue, l'objet n'est pas de type Error.\");\n    }\n}",
              "err": {},
              "uuid": "5dd5d530-4074-408a-87e1-fa9f0e73aea7",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit insérer un board et le récupérer par son ID",
              "fullTitle": "Tests de base de données doit insérer un board et le récupérer par son ID",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const user = await pool.query('SELECT * FROM users WHERE name = $1', [\n    'tester1',\n]);\nconst userId = user.rows[0].id;\nconst resultInsert = await pool.query('INSERT INTO boards (id, user_id, name) VALUES ($1, $2, $3) RETURNING *', ['25677a65-73c9-4a6c-bc70-482f37200725', userId, 'Projet Test']);\nconst boardId = resultInsert.rows[0].id;\nconst resultSelect = await pool.query('SELECT * FROM boards WHERE id = $1', [boardId]);\nassert.equal(resultSelect.rows[0].name, 'Projet Test');\nassert.equal(resultSelect.rows[0].user_id, userId);",
              "err": {},
              "uuid": "33c3cd33-455e-454e-8fb4-b4f6bcc1592e",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit mettre à jour le nom d'un board",
              "fullTitle": "Tests de base de données doit mettre à jour le nom d'un board",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const board = await pool.query('SELECT * FROM boards WHERE name = $1', [\n    'Projet Test',\n]);\nconst boardId = board.rows[0].id;\nconst result = await pool.query('UPDATE boards SET name = $1 WHERE id = $2', ['Projet mis à jour', boardId]);\nconst updatedBoard = await pool.query('SELECT * FROM boards WHERE id = $1', [boardId]);\nassert.equal(result.rowCount, 1);\nassert.equal(updatedBoard.rows[0].name, 'Projet mis à jour');",
              "err": {},
              "uuid": "32cd73a5-b5e5-47e1-9a5a-58c90f3b6084",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit insérer une colonne",
              "fullTitle": "Tests de base de données doit insérer une colonne",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const board = await pool.query('SELECT * FROM boards WHERE name = $1', [\n    'Projet mis à jour',\n]);\nconst boardId = board.rows[0].id;\nawait pool.query('INSERT INTO columns (id, board_id, name) VALUES ($1, $2, $3)', ['526e2c21-844e-4c11-ac5b-473303e88306', boardId, 'En cours']);\nconst result = await pool.query('SELECT * FROM columns WHERE board_id = $1 AND name = $2', [boardId, 'En cours']);\nassert.equal(result.rowCount, 1);\nassert.equal(result.rows[0].name, 'En cours');",
              "err": {},
              "uuid": "60eee1f6-0b3a-4807-a438-268fcb6275c3",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas insérer une colonne sans board_id valide",
              "fullTitle": "Tests de base de données ne doit pas insérer une colonne sans board_id valide",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "try {\n    const invalidUUID = uuidv4();\n    await pool.query('INSERT INTO columns (id, board_id, name) VALUES ($1, $2, $3)', [\n        'de87cd7c-dc89-4f21-8ac4-2e2d2ac49612',\n        invalidUUID,\n        'En attente',\n    ]);\n    assert.fail(\"L'insertion devrait échouer avec un board_id invalide.\");\n}\ncatch (error) {\n    if (error instanceof Error) {\n        // On normalise le message d'erreur sinon la comparaison ne fonctionne pas\n        const cleanMessage = error.message\n            .toLowerCase()\n            .replace(/\\s+/g, ' ')\n            .trim();\n        assert.ok(cleanMessage.includes('viole la contrainte de clé étrangère'), `Erreur inattendue : ${cleanMessage}`);\n    }\n    else {\n        assert.fail(\"Erreur inattendue, l'objet n'est pas de type Error.\");\n    }\n}",
              "err": {},
              "uuid": "7e66c89a-e5d1-4b4d-b081-b34ddeedc6c0",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit modifier une colonne par son ID",
              "fullTitle": "Tests de base de données doit modifier une colonne par son ID",
              "timedOut": false,
              "duration": 6,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const column = await pool.query('SELECT * FROM columns WHERE name = $1', ['En cours']);\nconst columnId = column.rows[0].id;\nawait pool.query('UPDATE columns SET name = $1 WHERE id = $2', [\n    'En ce moment',\n    columnId,\n]);\nconst result = await pool.query('SELECT * FROM columns WHERE id = $1', [\n    columnId,\n]);\nassert.equal(result.rowCount, 1);\nassert.equal(result.rows[0].name, 'En ce moment');",
              "err": {},
              "uuid": "210701ec-4c20-4b0d-a8a5-9d22f71a1388",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit insérer une tâche",
              "fullTitle": "Tests de base de données doit insérer une tâche",
              "timedOut": false,
              "duration": 2,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const column = await pool.query('SELECT * FROM columns WHERE name = $1', ['En ce moment']);\nconst columnId = column.rows[0].id;\nawait pool.query('INSERT INTO tasks (id, column_id, name, description) VALUES ($1, $2, $3, $4)', [\n    'd149a698-ad09-4518-a671-336526e97918',\n    columnId,\n    'tâche test',\n    'Ceci est une tâche test.',\n]);\nconst result = await pool.query('SELECT * FROM tasks WHERE name = $1', [\n    'tâche test',\n]);\nassert.equal(result.rows[0].description, 'Ceci est une tâche test.');",
              "err": {},
              "uuid": "5224cfdb-24ed-435c-a673-0be8ceb3a776",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit modifier le nom d'une tâche par l'ID",
              "fullTitle": "Tests de base de données doit modifier le nom d'une tâche par l'ID",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const task = await pool.query('SELECT * FROM tasks WHERE name = $1', [\n    'tâche test',\n]);\nconst taskId = task.rows[0].id;\nawait pool.query('UPDATE tasks SET name = $1 WHERE id = $2', [\n    'tâche mis à jour',\n    taskId,\n]);\nconst result = await pool.query('SELECT * FROM tasks WHERE id = $1', [\n    taskId,\n]);\nassert.equal(result.rows[0].name, 'tâche mis à jour');",
              "err": {},
              "uuid": "3f4ab40a-52d5-49f5-b8b8-dce9615ce8bf",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit modifier la description d'une tâche par l'ID",
              "fullTitle": "Tests de base de données doit modifier la description d'une tâche par l'ID",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const task = await pool.query('SELECT * FROM tasks WHERE name = $1', [\n    'tâche mis à jour',\n]);\nconst taskId = task.rows[0].id;\nawait pool.query('UPDATE tasks SET description = $1 WHERE id = $2', [\n    'La description est mis à jour.',\n    taskId,\n]);\nconst result = await pool.query('SELECT * FROM tasks WHERE id = $1', [\n    taskId,\n]);\nassert.equal(result.rows[0].description, 'La description est mis à jour.');",
              "err": {},
              "uuid": "a785ee76-a9f9-49fb-a45c-e93a128035ce",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit supprimer une tâche par son ID",
              "fullTitle": "Tests de base de données doit supprimer une tâche par son ID",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const task = await pool.query('SELECT * FROM tasks WHERE name = $1', [\n    'tâche mis à jour',\n]);\nconst taskId = task.rows[0].id;\nawait pool.query('DELETE FROM columns WHERE id = $1', [taskId]);\nconst result = await pool.query('SELECT * FROM columns WHERE id = $1', [\n    taskId,\n]);\nassert.equal(result.rowCount, 0);",
              "err": {},
              "uuid": "1af280a3-9ab8-47a9-90c7-9e1f9b6d878e",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit supprimer une colonne par son ID",
              "fullTitle": "Tests de base de données doit supprimer une colonne par son ID",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const column = await pool.query('SELECT * FROM columns WHERE name = $1', ['En ce moment']);\nconst columnId = column.rows[0].id;\nawait pool.query('DELETE FROM columns WHERE id = $1', [columnId]);\nconst result = await pool.query('SELECT * FROM columns WHERE id = $1', [\n    columnId,\n]);\nassert.equal(result.rowCount, 0);",
              "err": {},
              "uuid": "b9f5f61e-a84b-4e57-88f1-b163dcaf002a",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit supprimer un board par son ID",
              "fullTitle": "Tests de base de données doit supprimer un board par son ID",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const board = await pool.query('SELECT * FROM boards WHERE name = $1', [\n    'Projet mis à jour',\n]);\nconst boardId = board.rows[0].id;\nawait pool.query('DELETE FROM boards WHERE id = $1', [boardId]);\nconst result = await pool.query('SELECT * FROM boards WHERE id = $1', [\n    boardId,\n]);\nassert.equal(result.rowCount, 0);",
              "err": {},
              "uuid": "2786e41f-204f-40e9-b97c-cd3fa4ba7c2a",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit supprimer un utilisateur",
              "fullTitle": "Tests de base de données doit supprimer un utilisateur",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('DELETE FROM users WHERE name = $1 RETURNING *', ['tester1']);\n// Si la suppression a réussi, rowCount renverra le nombre de ligne supprimé\n// Ici, on supprime 1 utilisateur, soit 1 ligne\nassert.equal(result.rowCount, 1);\nassert.equal(result.rows[0].name, 'tester1');\nconst checkUser = await pool.query('SELECT * FROM users WHERE name = $1', ['tester']);\n// Si aucune ligne n'est retourné, rowCount renverra 0\nassert.equal(checkUser.rowCount, 0);",
              "err": {},
              "uuid": "60048c00-edc7-4147-952f-45cc52132551",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit supprimer un second utilisateur",
              "fullTitle": "Tests de base de données doit supprimer un second utilisateur",
              "timedOut": false,
              "duration": 1,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('DELETE FROM users WHERE name = $1 RETURNING *', ['tester2']);\n// Si la suppression a réussi, rowCount renverra le nombre de ligne supprimé\n// Ici, on supprime 1 utilisateur, soit 1 ligne\nassert.equal(result.rowCount, 1);\nassert.equal(result.rows[0].name, 'tester2');\nconst checkUser = await pool.query('SELECT * FROM users WHERE name = $1', ['tester']);\n// Si aucune ligne n'est retourné, rowCount renverra 0\nassert.equal(checkUser.rowCount, 0);",
              "err": {},
              "uuid": "4ac57c2f-9cbf-4d19-88eb-4b8273fea8de",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "ne doit pas supprimer un utilisateur qui n'existe pas",
              "fullTitle": "Tests de base de données ne doit pas supprimer un utilisateur qui n'existe pas",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const result = await pool.query('DELETE FROM users WHERE name = $1 RETURNING *', ['inexistant']);\nassert.equal(result.rowCount, 0);",
              "err": {},
              "uuid": "0884783d-15ce-411a-9184-fb16d7213e92",
              "parentUUID": "714e97bd-c1cf-4ed1-bf5c-e372d2a6e066",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "ba4dea07-829c-4235-98ae-fe4a45cc9ec9",
            "80530f5e-be5a-405d-8ac3-767ed2408fae",
            "3a1460c0-5911-4407-8bb8-6fb38dd40605",
            "4b2f1e69-9ce3-4c2c-ad46-1ce23c99296f",
            "b1ef3c1b-4052-4156-8ae4-3b0b9155738b",
            "772b6b60-a7ca-4aa7-b7a9-88e014a4c835",
            "481f8109-ba19-446d-8338-871f5f60d402",
            "cc33f09a-2428-489a-bf41-2d08cf208857",
            "3c143ca4-2d4b-41bd-8d85-fb47182f7ed7",
            "f0d0b866-59df-421a-be60-95ae39cf97cd",
            "5dd5d530-4074-408a-87e1-fa9f0e73aea7",
            "33c3cd33-455e-454e-8fb4-b4f6bcc1592e",
            "32cd73a5-b5e5-47e1-9a5a-58c90f3b6084",
            "60eee1f6-0b3a-4807-a438-268fcb6275c3",
            "7e66c89a-e5d1-4b4d-b081-b34ddeedc6c0",
            "210701ec-4c20-4b0d-a8a5-9d22f71a1388",
            "5224cfdb-24ed-435c-a673-0be8ceb3a776",
            "3f4ab40a-52d5-49f5-b8b8-dce9615ce8bf",
            "a785ee76-a9f9-49fb-a45c-e93a128035ce",
            "1af280a3-9ab8-47a9-90c7-9e1f9b6d878e",
            "b9f5f61e-a84b-4e57-88f1-b163dcaf002a",
            "2786e41f-204f-40e9-b97c-cd3fa4ba7c2a",
            "60048c00-edc7-4147-952f-45cc52132551",
            "4ac57c2f-9cbf-4d19-88eb-4b8273fea8de",
            "0884783d-15ce-411a-9184-fb16d7213e92"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 52,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        },
        {
          "uuid": "41a30f30-171e-4e50-878d-396e328f80fd",
          "title": "UserService",
          "fullFile": "/home/johan/Repository/ikanban/backend/test/2-userService.test.ts",
          "file": "/test/2-userService.test.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"UserService\"",
              "fullTitle": "UserService \"before each\" hook in \"UserService\"",
              "timedOut": false,
              "duration": 1,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "userService = new UserServiceTestable();\n// Création d'une fausse instance de UserDb\nuserDbStub = sinon.createStubInstance(UserDb);\nuserService['userDb'] = userDbStub;",
              "err": {},
              "uuid": "5b8b3cc3-c566-4626-9343-a19756c4c8df",
              "parentUUID": "41a30f30-171e-4e50-878d-396e328f80fd",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [
            {
              "title": "\"after each\" hook in \"UserService\"",
              "fullTitle": "UserService \"after each\" hook in \"UserService\"",
              "timedOut": false,
              "duration": 0,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "sinon.restore();",
              "err": {},
              "uuid": "4a1cb28f-7ee7-4bc6-965e-0e6b327056b9",
              "parentUUID": "41a30f30-171e-4e50-878d-396e328f80fd",
              "isHook": true,
              "skipped": false
            }
          ],
          "tests": [
            {
              "title": "doit créer un utilisateur avec succès et le retourner sans le mot de passe haché",
              "fullTitle": "UserService doit créer un utilisateur avec succès et le retourner sans le mot de passe haché",
              "timedOut": false,
              "duration": 108,
              "state": "passed",
              "speed": "slow",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "// 1. Déclaration des données nécéssaires pour créer un nouvel utilisateur\nconst newUser = {\n    name: 'John Doe',\n    email: 'john@example.com',\n    password: 'Password123!',\n    passconf: 'Password123!',\n};\n// 2. Déclaration des données nécéssaires pour insérer le nouvel utilisateur dans la DB\nconst fakeUser = {\n    id: '1',\n    name: newUser.email,\n    email: newUser.email,\n    password_hash: 'hashed_password_123',\n};\nuserDbStub.findByMail.resolves(null); // Simule email est unique\nuserDbStub.create.resolves(fakeUser); // Simule l'appel à la db\nconst result = await userService.createUser(newUser);\n// Je vérifie que les méthodes simulées ont bien été appelées\nexpect(userDbStub.create.calledOnce).to.be.true;\nexpect(userDbStub.findByMail.calledWith(newUser.email)).to.be.true;\nexpect(result).to.deep.equal({\n    id: fakeUser.id,\n    name: fakeUser.name,\n    email: fakeUser.email,\n});",
              "err": {},
              "uuid": "3170d44e-b9aa-429d-8796-81fcd06740cd",
              "parentUUID": "41a30f30-171e-4e50-878d-396e328f80fd",
              "isHook": false,
              "skipped": false
            },
            {
              "title": "doit supprimer un utilisateur avec succès",
              "fullTitle": "UserService doit supprimer un utilisateur avec succès",
              "timedOut": false,
              "duration": 0,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "const fakeUserId = '1';\n// La méthode retourne true\nuserDbStub.delete.resolves(true);\nconst result = await userService.deleteUser(fakeUserId);\nexpect(result).to.be.true;\nexpect(userDbStub.delete.calledOnceWith(fakeUserId)).to.be.true;",
              "err": {},
              "uuid": "ee347559-6044-4be3-8c5c-f51ab6e6da75",
              "parentUUID": "41a30f30-171e-4e50-878d-396e328f80fd",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [
            {
              "uuid": "52254573-8e39-4e2a-ae8f-02a5526f32ec",
              "title": "validatePasswordMatch",
              "fullFile": "/home/johan/Repository/ikanban/backend/test/2-userService.test.ts",
              "file": "/test/2-userService.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "ne doit pas lancer d'erreur si les mots de passe correspondent",
                  "fullTitle": "UserService validatePasswordMatch ne doit pas lancer d'erreur si les mots de passe correspondent",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "expect(() => userService.testValidatePasswordsMatch('Azerty1!', 'Azerty1!')).to.not.throw();",
                  "err": {},
                  "uuid": "219acb04-90fd-45ef-a9fa-6ee7a78a3ec2",
                  "parentUUID": "52254573-8e39-4e2a-ae8f-02a5526f32ec",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit renvoyer une erreur si les mots de passe ne correspondent pas",
                  "fullTitle": "UserService validatePasswordMatch doit renvoyer une erreur si les mots de passe ne correspondent pas",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "expect(() => userService.testValidatePasswordsMatch('Azerty1!', 'ytreza')).to.throw('Le mot de passe et sa confirmation ne correspondent pas');",
                  "err": {},
                  "uuid": "c3580f40-b220-407b-b5f3-1150518c9efa",
                  "parentUUID": "52254573-8e39-4e2a-ae8f-02a5526f32ec",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "219acb04-90fd-45ef-a9fa-6ee7a78a3ec2",
                "c3580f40-b220-407b-b5f3-1150518c9efa"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 1,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "a46bb112-99aa-4f47-880a-7bd3815ff9f0",
              "title": "hashPassword",
              "fullFile": "/home/johan/Repository/ikanban/backend/test/2-userService.test.ts",
              "file": "/test/2-userService.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "doit retourner une chaîne non vide différente du mot de passe",
                  "fullTitle": "UserService hashPassword doit retourner une chaîne non vide différente du mot de passe",
                  "timedOut": false,
                  "duration": 96,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const plainPassword = 'Azerty1!';\nconst saltRounds = 10;\nconst hashed = userService.testHashPassword(saltRounds, plainPassword);\nexpect(hashed).to.be.a('string').and.not.empty;\nexpect(hashed).to.not.equal(plainPassword);",
                  "err": {},
                  "uuid": "decfa055-57fe-4705-8cb2-d76f327553b6",
                  "parentUUID": "a46bb112-99aa-4f47-880a-7bd3815ff9f0",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit produire des hashes différents pour le même mot de passe",
                  "fullTitle": "UserService hashPassword doit produire des hashes différents pour le même mot de passe",
                  "timedOut": false,
                  "duration": 190,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const plainPassword = 'Azerty1!';\nconst saltRounds = 10;\nconst hash1 = userService.testHashPassword(saltRounds, plainPassword);\nconst hash2 = userService.testHashPassword(saltRounds, plainPassword);\nexpect(hash1).to.not.equal(hash2);",
                  "err": {},
                  "uuid": "c7caca80-0b3e-480e-82f2-bd14e3691847",
                  "parentUUID": "a46bb112-99aa-4f47-880a-7bd3815ff9f0",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "decfa055-57fe-4705-8cb2-d76f327553b6",
                "c7caca80-0b3e-480e-82f2-bd14e3691847"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 286,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "59222cf1-68c1-4dde-9330-1f007b06af27",
              "title": "verifyCredentials",
              "fullFile": "/home/johan/Repository/ikanban/backend/test/2-userService.test.ts",
              "file": "/test/2-userService.test.ts",
              "beforeHooks": [
                {
                  "title": "\"before each\" hook in \"verifyCredentials\"",
                  "fullTitle": "UserService verifyCredentials \"before each\" hook in \"verifyCredentials\"",
                  "timedOut": false,
                  "duration": 0,
                  "state": null,
                  "speed": null,
                  "pass": false,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "userDbStub = sinon.createStubInstance(UserDb);\nuserService = new UserService();\n// @ts-ignore accès direct pour injection manuelle du stub\nuserService['userDb'] = userDbStub;",
                  "err": {},
                  "uuid": "802ca207-ad3b-47b4-83b4-5eef82147a09",
                  "parentUUID": "59222cf1-68c1-4dde-9330-1f007b06af27",
                  "isHook": true,
                  "skipped": false
                }
              ],
              "afterHooks": [],
              "tests": [
                {
                  "title": "doit rejeter si l'email est vide",
                  "fullTitle": "UserService verifyCredentials doit rejeter si l'email est vide",
                  "timedOut": false,
                  "duration": 4,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "await expect(userService.verifyCredentials('', 'Azerty1!')).to.be.rejectedWith('Email ou mot de passe requis');",
                  "err": {},
                  "uuid": "d15035f4-505c-4fb0-814f-8eabf7ff91a9",
                  "parentUUID": "59222cf1-68c1-4dde-9330-1f007b06af27",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit rejeter si l'utilisateur n'existe pas",
                  "fullTitle": "UserService verifyCredentials doit rejeter si l'utilisateur n'existe pas",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "userDbStub.findByMail.resolves(null);\nawait expect(userService.verifyCredentials('john@example.com', 'pass123')).to.be.rejectedWith('Les identifiants sont invalides');",
                  "err": {},
                  "uuid": "f1b2f161-d9d8-432d-8879-69001d1c6942",
                  "parentUUID": "59222cf1-68c1-4dde-9330-1f007b06af27",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit rejeter si le mot de passe est incorrect",
                  "fullTitle": "UserService verifyCredentials doit rejeter si le mot de passe est incorrect",
                  "timedOut": false,
                  "duration": 96,
                  "state": "passed",
                  "speed": "slow",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "userDbStub.findByMail.resolves({\n    id: '1',\n    name: 'John',\n    email: 'john@example.com',\n    password_hash: '$2b$10$123456789012345678901uIrZTpkUCxNi9/5kxz38yaeI9lQ6JLzi', // faux hash\n});\nawait expect(userService.verifyCredentials('john@example.com', 'wrongpass')).to.be.rejectedWith('Les identifiants sont invalides');",
                  "err": {},
                  "uuid": "a348e2ae-4a02-43fe-9880-c68eb306b7ff",
                  "parentUUID": "59222cf1-68c1-4dde-9330-1f007b06af27",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit retourner l'utilisateur si l'authentification est réussi",
                  "fullTitle": "UserService verifyCredentials doit retourner l'utilisateur si l'authentification est réussi",
                  "timedOut": false,
                  "duration": 0,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "",
                  "err": {},
                  "uuid": "095e307f-3b73-4b26-b2dd-82d6143dd2da",
                  "parentUUID": "59222cf1-68c1-4dde-9330-1f007b06af27",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "d15035f4-505c-4fb0-814f-8eabf7ff91a9",
                "f1b2f161-d9d8-432d-8879-69001d1c6942",
                "a348e2ae-4a02-43fe-9880-c68eb306b7ff",
                "095e307f-3b73-4b26-b2dd-82d6143dd2da"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 100,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            }
          ],
          "passes": [
            "3170d44e-b9aa-429d-8796-81fcd06740cd",
            "ee347559-6044-4be3-8c5c-f51ab6e6da75"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 108,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        },
        {
          "uuid": "81cb115d-39b3-4390-9c9d-325b39067575",
          "title": "UserController",
          "fullFile": "/home/johan/Repository/ikanban/backend/test/3-userController.test.ts",
          "file": "/test/3-userController.test.ts",
          "beforeHooks": [
            {
              "title": "\"before each\" hook in \"UserController\"",
              "fullTitle": "UserController \"before each\" hook in \"UserController\"",
              "timedOut": false,
              "duration": 1,
              "state": null,
              "speed": null,
              "pass": false,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "// Créer une instance du contrôleur\nuserServiceStub = sinon.createStubInstance(UserService);\nuserController = new UserController();\nuserController['userService'] = userServiceStub;",
              "err": {},
              "uuid": "4fbb685d-030c-447b-9add-4fd2ed3e8d18",
              "parentUUID": "81cb115d-39b3-4390-9c9d-325b39067575",
              "isHook": true,
              "skipped": false
            }
          ],
          "afterHooks": [],
          "tests": [],
          "suites": [
            {
              "uuid": "e3d42fb3-9de4-48be-a39b-8608a4108394",
              "title": "registerUser",
              "fullFile": "/home/johan/Repository/ikanban/backend/test/3-userController.test.ts",
              "file": "/test/3-userController.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "doit créer un utilisateur avec succès",
                  "fullTitle": "UserController registerUser doit créer un utilisateur avec succès",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const req = {\n    body: {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123!',\n        passconf: 'password123!',\n    },\n};\nconst res = {\n    status: sinon.stub().returnsThis(), // Permet de chaîner les appels\n    json: sinon.stub(),\n    sendStatus: sinon.stub(),\n};\n// Simuler une réponse réussie de createUser sur le stub\nuserServiceStub.createUser.resolves({\n    id: '1',\n    name: 'John Doe',\n    email: 'john@example.com',\n});\n// Appeler la méthode du contrôleur\nawait userController.registerUser(req, res);\n// Vérifier que status a été appelé avec 201 et json avec les bonnes données\nexpect(res.status.calledWith(201)).to.be.true;\nexpect(res.json.calledWith({\n    success: true,\n    message: 'Votre compte a été créé',\n    data: {\n        id: '1',\n        name: 'John Doe',\n        email: 'john@example.com',\n    },\n})).to.be.true;",
                  "err": {},
                  "uuid": "51365131-fbfb-4ed5-a0b1-8c5a9580c796",
                  "parentUUID": "e3d42fb3-9de4-48be-a39b-8608a4108394",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit renvoyer une erreur si l'utilisateur existe déjà",
                  "fullTitle": "UserController registerUser doit renvoyer une erreur si l'utilisateur existe déjà",
                  "timedOut": false,
                  "duration": 2,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "// Configurer le stub pour générer l'erreur\nconst tableExistsError = new Error('Impossible de créer le compte');\nuserServiceStub.createUser.rejects(tableExistsError);\n// Préparer la requête\nconst req = {\n    body: {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123!',\n        passconf: 'password123!',\n    },\n};\nconst res = {\n    status: sinon.stub().returnsThis(),\n    json: sinon.stub(),\n    sendStatus: sinon.stub(),\n};\nawait userController.registerUser(req, res);\nexpect(res.status.calledWith(409)).to.be.true;\nexpect(res.json.calledWith({\n    success: false,\n    error: 'Impossible de créer le compte',\n})).to.be.true;",
                  "err": {},
                  "uuid": "74c8e90e-4a57-42dd-880c-6d7dbfdbacfb",
                  "parentUUID": "e3d42fb3-9de4-48be-a39b-8608a4108394",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit renvoyer une erreur 500 en cas d'erreur du serveur",
                  "fullTitle": "UserController registerUser doit renvoyer une erreur 500 en cas d'erreur du serveur",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const req = {\n    body: {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123!',\n        passconf: 'password123!',\n    },\n};\nconst res = {\n    status: sinon.stub().returnsThis(),\n    json: sinon.stub(),\n    sendStatus: sinon.stub(),\n};\nuserServiceStub.createUser.rejects(new Error('Erreur serveur inconnue.'));\nawait userController.registerUser(req, res);\nexpect(res.status.calledWith(500)).to.be.true;\nexpect(res.json.calledWith({\n    success: false,\n    error: 'Erreur serveur inconnue',\n})).to.be.true;",
                  "err": {},
                  "uuid": "b610c296-7b45-445f-a5fb-a6340a365b58",
                  "parentUUID": "e3d42fb3-9de4-48be-a39b-8608a4108394",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "51365131-fbfb-4ed5-a0b1-8c5a9580c796",
                "74c8e90e-4a57-42dd-880c-6d7dbfdbacfb",
                "b610c296-7b45-445f-a5fb-a6340a365b58"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 5,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            },
            {
              "uuid": "77f4506f-9512-4986-8c0d-8104dc6c86f9",
              "title": "fetchUserById",
              "fullFile": "/home/johan/Repository/ikanban/backend/test/3-userController.test.ts",
              "file": "/test/3-userController.test.ts",
              "beforeHooks": [],
              "afterHooks": [],
              "tests": [
                {
                  "title": "doit récupérer l'utilisateur par son ID",
                  "fullTitle": "UserController fetchUserById doit récupérer l'utilisateur par son ID",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const req = {\n    params: {\n        userId: '1',\n    },\n};\nconst res = {\n    status: sinon.stub().returnsThis(),\n    json: sinon.stub(),\n    sendStatus: sinon.stub(),\n};\nuserServiceStub.getUserById.resolves({\n    id: '1',\n    name: 'John Doe',\n    email: 'john@example.com',\n});\nawait userController.fetchUserById(req, res);\nexpect(res.status.calledWith(200)).to.be.true;\nexpect(res.json.calledWith({\n    id: '1',\n    name: 'John Doe',\n    email: 'john@example.com',\n})).to.be.true;",
                  "err": {},
                  "uuid": "fc5e90da-d916-4410-ba22-cfaf211e627b",
                  "parentUUID": "77f4506f-9512-4986-8c0d-8104dc6c86f9",
                  "isHook": false,
                  "skipped": false
                },
                {
                  "title": "doit retourner 404 si l'utilisateur n'est pas trouvé",
                  "fullTitle": "UserController fetchUserById doit retourner 404 si l'utilisateur n'est pas trouvé",
                  "timedOut": false,
                  "duration": 1,
                  "state": "passed",
                  "speed": "fast",
                  "pass": true,
                  "fail": false,
                  "pending": false,
                  "context": null,
                  "code": "const req = {\n    params: {\n        userId: 'non-existent-id',\n    },\n};\nconst res = {\n    status: sinon.stub().returnsThis(),\n    json: sinon.stub(),\n    sendStatus: sinon.stub(),\n};\nuserServiceStub.getUserById.resolves(undefined);\nawait userController.fetchUserById(req, res);\nexpect(res.sendStatus.calledWith(404)).to.be.true;",
                  "err": {},
                  "uuid": "f1dd5c3a-98c2-4b1d-977d-c15f5235fb1b",
                  "parentUUID": "77f4506f-9512-4986-8c0d-8104dc6c86f9",
                  "isHook": false,
                  "skipped": false
                }
              ],
              "suites": [],
              "passes": [
                "fc5e90da-d916-4410-ba22-cfaf211e627b",
                "f1dd5c3a-98c2-4b1d-977d-c15f5235fb1b"
              ],
              "failures": [],
              "pending": [],
              "skipped": [],
              "duration": 2,
              "root": false,
              "rootEmpty": false,
              "_timeout": 2000
            }
          ],
          "passes": [],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 0,
          "root": false,
          "rootEmpty": false,
          "_timeout": 2000
        },
        {
          "uuid": "cfd80bba-c117-4945-9658-fdb7ba24de26",
          "title": "Nettoyage des tests",
          "fullFile": "/home/johan/Repository/ikanban/backend/test/4-clean.test.ts",
          "file": "/test/4-clean.test.ts",
          "beforeHooks": [],
          "afterHooks": [],
          "tests": [
            {
              "title": "doit nettoyer toutes les données de tests",
              "fullTitle": "Nettoyage des tests doit nettoyer toutes les données de tests",
              "timedOut": false,
              "duration": 22,
              "state": "passed",
              "speed": "fast",
              "pass": true,
              "fail": false,
              "pending": false,
              "context": null,
              "code": "console.log('Fermeture de toute les connexions.');\nawait pool.end();\nawait dropTestDB(config.db.database);\nconsole.log(\"Nettoyage terminée.\");",
              "err": {},
              "uuid": "8606f060-417b-4d21-b695-58cf30400c44",
              "parentUUID": "cfd80bba-c117-4945-9658-fdb7ba24de26",
              "isHook": false,
              "skipped": false
            }
          ],
          "suites": [],
          "passes": [
            "8606f060-417b-4d21-b695-58cf30400c44"
          ],
          "failures": [],
          "pending": [],
          "skipped": [],
          "duration": 22,
          "root": false,
          "rootEmpty": false,
          "_timeout": 6000
        }
      ],
      "passes": [],
      "failures": [],
      "pending": [],
      "skipped": [],
      "duration": 0,
      "root": true,
      "rootEmpty": true,
      "_timeout": 2000
    }
  ],
  "meta": {
    "mocha": {
      "version": "11.5.0"
    },
    "mochawesome": {
      "options": {
        "quiet": false,
        "reportFilename": "mochawesome",
        "saveHtml": true,
        "saveJson": true,
        "consoleReporter": "spec",
        "useInlineDiffs": false,
        "code": true
      },
      "version": "7.1.3"
    },
    "marge": {
      "options": null,
      "version": "6.2.0"
    }
  }
}